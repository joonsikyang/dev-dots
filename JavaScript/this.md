# 1. 상황에 따라 달라지는 this

- 자바스크립트에서 this는 실행 컨텍스트가 생성될 때 함께 결정됩니다.

- 실행 컨텍스트는 함수를 호출할 때 생성되므로, 바꿔 말하면 this는 함수를 호출할 때 결정됩니다.

- 즉, 함수를 어떤 방식으로 호출 하느냐에 따라 this 가 바라보는 대상이 결정됩니다.

- 상황별로 this가 어떻게 달라지는지, 예삳과 다른 대상을 바라보고 있는 경우 해결 방법에 대해 알아봅시다.

<br />

1. ***전역 공간에서의 this***

    : 전역 공간에서의 this는 전역객체(window, global)를 참조합니다.

2. ***메서드로 호출할 때 그 메서드 내부에서의 this***

    : 메서드로 함수를 호출한 경우 this는 메서드 호출 주체(메서드명 앞의 객체)를 참조합니다.

3. ***함수로서 호출할 때 그 함수 내부에서의 this***

    : 함수를 함수로 호출한 경우 this는 전역 객체를 참조합니다. 메서드의 내부함수에서도 같습니다.

4. ***콜백 함수 호출 시 그 함수 내부에서의 this***

    : 콜백 함수 내부에서의 this는 해당 콜백 함수의 제어권을 넘겨받은 함수가 정의한 바에 따르며, 정의하지 않은 경우에는 전역객체를 참조합니다.

5. ***생성자 함수 내부에서의 this***

    : 생성자 함수에서의 this는 생성될 인스턴스를 참조합니다.

<br />

## 1-1. 전역 공간에서의 this
- 전역 공간에서의 this 는 전역 객체를 가리킵니다.

- 전역 컨텍스트를 생성하는 주체가 전역 객체이기 때문입니다.

- 참고) 자바스크립트 런타임 환경에 따라 다른 전역 객체 : 브라우저 환경 - `window` / Node.js 환경 - `global`

- 참고) 전역 공간에서만 발생하는 특이한 성질
    - 전역 변수를 선언하면 자바스크립트 엔진은 이를 전역 객체의 프로퍼티로 할당합니다.
        ```jsx
        var a = 1;

        console.log(a); // 1
        console.log(window.a); // 1
        console.log(this.a); // 1
        ```
    - 그 이유는 자바스크립트의 모든 변수는 실은 특정 객체의 프로퍼티로서 동작하기 때문입니다.
    - 특정 객체란 바로 실행 컨텍스트의 `LexicalEnvironment` 입니다.
    - 실행 컨텍스트는 변수를 수집해서 L.E 의 프로퍼티로 저장합니다.
    - 어떤 변수를 호출하면 L.E 를 조회해서 일치하는 프로퍼티가 있을 경우 그 값을 반환합니다.
    - 전역 컨텍스트의 경우 L.E는 전역 객체를 그대로 참조합니다.
    
        - 더 정확하게는 `GlobalEnv` 가 전역객체를 참조하는데, 전역 객체의 L.E가 이 `GlobalEnv` 를 참조합니다.
    
    - 그렇다면 `window.a`, `this.a` 가 1이 나오는 이유는 설명되는데, `a` 를 직접 호출할 때도 1이 나오는 까닭은? >>> 스코프 체인
        
        - 변수 `a` 에 접근하고자 하면 스코프 체인에서 a를 검색하다가 가장 마지막에 도달하는 전역 스코프의 L.E, 즉 전역객체에서 해당 프로퍼티 a를 발견해서 그 값을 반환하기 때문입니다.
        
        - 단순하게 `window.` 이 생략된 것이라고 여겨도 무방합니다.
    
    - 전역 변수 선언과 전역 객체의 프로퍼티 할당의 차이점
        
        - `var` 로 선언한 전역변수와 전역객체의 프로퍼티는 `hoisting` 여부 및 `configurable` 여부에서 차이를 보입니다.
        
        - 일반적인 경우 동일하게 동작

            ```jsx
            var a = 1;

            console.log(a); // 1

            window.a = 3;

            console.log(a); // 3
            ```

        - '삭제' 명령에 관해서는 다르게 동작

            ```jsx
            var a = 1;
            delete window.a; // false >>> 전역 변수로 선언한 경우에는 삭제 불가
            console.log(a, window.a, this.a); // 1 1 1

            window.c = 3;
            delete window.c; // true >>> 전역객체의 프로퍼티로 할당한 경우에는 삭제 가능
            console.log(c, window.c, this.c); // Uncaught Reference Error: c is not defined
            ```

            - 처음부터 전역객체의 프로퍼티로 할당한 경우에는 삭제가 되는 반면, 전역변수로 선언한 경우에는 삭제가 되지 않습니다.
            
            - 이는 사용자가 의도치 않게 삭제하는 것을 방지하는 차원에서 마련한 나름의 방어 전략.
            
            - 즉 전역변수를 선언하면 자바스크립트 엔진이 이를 자동으로 전역객체의 프로퍼티로 할당하면서 추가적으로 해당 프로퍼티의 configurable 속성(변경 및 삭제 가능성)을 false로 정의하는 것입니다.

<br />

## 1-2. 메서드로 호출할 때 그 메서드 내부에서의 this

- **메서드 vs. 함수**
    - 함수를 실행하는 가장 일반적인 방법 두 가지 : 함수로서 호출 vs. 메서드로서 호출
    
    - 함수와 메서드는 미리 정의한 동작을 수행하는 코드 뭉치, 이 둘을 구분하는 유일한 차이는 `독립성`
    
    - **함수는 그 자체로 독립적인 기능을 수행, 메서드는 자신을 호출한 대상 객체에 관한 동작을 수행**
    
    - 서로 다른 호출 상황에서의 this
    
    - 어떤 함수를 객체의 프로퍼티에 할당한다고 해서 그 자체로서 무조건 메서드가 되는 것은 아니다.
    
    - 객체의 메서드로서 호출할 경우에만 메서드로 동작, 그렇지 않으면 함수로 동작
    
    - 함수로서의 호출과 메서드로서 호출을 구분하는 방법 → dot notation / bracket notation

- **메서드 내부에서의 this**
    
    - this 에는 호출한 주체에 대한 정보가 담깁니다.
    
    - 어떤 함수를 메서드로서 호출하는 경우 호출 주체는 바로 함수명(프로퍼티명) 앞의 객체입니다.

        ```jsx
        var obj = {
        	methodA: function () { console.log(this) },
        	inner: {
            methodB: function () { console.log(this) }
          } 
        };

        obj.methodA() // this === obj
        obj.inner.methodB() // this === obj.inner
        ```

<br />

## 1-3. 함수로서 호출할 때 그 함수 내부에서의 this

- (내용 작성중)

<br />

## 1-4. 콜백 함수 호출 시 그 함수 내부에서의 this

- B(A) → B : 제어권을 가진 함수, A : 콜백 함수

- 함수 A는 제어권을 가진 함수 B의 내부 로직에 따라 실행되며, this 역시 함수 B 내부의 로직에서 정한 규칙에 따라 값이 결정됩니다.

- 콜백 함수도 함수이기 때문에 기본적으로 this가 전역 객체를 참조하지만, 제어권을 받은 함수에서 콜백 함수에 별도로 this가 될 대상을 지정한 경우에는 그 대상을 참조하게 됩니다.

```jsx
setTimeout(function() { console.log(this) }, 300); // this === window

[1, 2, 3, 4, 5].forEach(function (x) {
  console.log(this, x); // this === window
});

document.body.innerHTML += `<button id="a">Click</button>`;

const button = document.body.querySelector('#a');

button.addEventListener('click', function (e) {
  console.log(this, e);  // this === button (메서드로서 호출)
}
```

- setTimeout 함수와 forEach 메서드는 그 내부에서 콜백 함수를 호출할 때 대상이 될 this를 지정하지 않습니다. 따라서 콜백 함수 내부에서의 this는 전역객체를 참조합니다.

- 한편 addEventListener 메서드는 콜백 함수를 호출할 때 자신의 this를 상속하도록 정의돼 있습니다. 곧 메서드명의 점 앞부분이 곧 this가 됩니다.

- 이처럼 콜백 함수에서의 this는 무조건 답이 정해져 있지 않습니다. 

- 콜백 함수의 제어권을 가지는 함수(메서드)가 콜백 함수에서의 this를 무엇으로 할지를 결정하며, 특별히 정의하지 않은 경우에는 기본적으로 함수와 마찬가지로 전역 객체를 바라봅니다.

<br />

## 1-5. 생성자 함수 내부에서의 this

- 생성자 함수
    
    - 어떤 공통된 성질을 지니는 객체들을 생성하는 데 사용하는 함수
    - 객체지향 언어에서는 생성자를 클래스, 클래스를 통해 만든 객체를 인스턴스 라고 부른다.    
    - 프로그래밍적으로 '생성자'는 구체적인 인스턴스를 만들기 위한 일종의 틀    
    - 이 틀에는 클래스의 공통 속성들이 미리 준비돼 있고, 여기에 구체적인 인스턴스의 개성을 더해 개별 인스턴스를 만들 수 있는 것

- 자바스크립트는 함수에 생성자로서의 역할을 함께 부여했습니다.

- `new` 명령어와 함게 함수를 호출하면 해당 함수가 생성자로서 동작하게 됩니다.

- **그리고 어떤 함수가 생성자 함수로서 호출된 경우 내부에서의 this는 곧 새로 만들 구체적인 인스턴스 자신이 됩니다.**

- 생성자 함수 호출 시
    - 생성자 함수를 호출하면 (new 명령어와 함께 함수를 호출하면)
    - 우선 생성자의 prototype 프로퍼티를 참조하는 `__proto__` 라는 프로퍼티가 있는 객체(인스턴스)를 만들고,
    - 미리 준비된 공통 속성 및 개성을 해당 객체(this)에 부여
    - 이렇게 해서 구체적인 인스턴스가 생성됨

```jsx
var Cat = function (name, age) {
  this.bark = '야옹';
  this.name = name;
  this.age = age;
}

var choco = new Cat('초코', 7);
var nabi = new Cat('나비', 5);

console.log(choco) // { bark: '야옹', name: '초코', age: 7 }
console.log(nabi) // { bark: '야옹', name: '나비', age: 5 }
```

- Cat 이란 변수에 익명 함수를 할당. 이 함수 내부에서는 this에 접근하여 bark, name, age 프로퍼티에 각각 값을 대입
- new 명령어와 함께 Cat 함수를 호출하여 생성된 인스턴스를 변수 choco, nabi 에 각각 할당

<br />
